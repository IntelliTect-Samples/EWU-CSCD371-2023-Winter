# Assignment

## Overview

For this assignment, we are going to continue with C# object-oriented concept by expanding Assignment2 to use records, value types, enums, and developing well-formed types in general.

## Reading

Read **Chapters 9 - Introducing Structs and Records & Chapter 10 - Well Formed Typed**

## Assignment

- Define a full name record (first, last, middle) handling optional and null appropriately.
- Provide a comment on the full name record on why you selected to define a value or a reference type and why or why not the type is immutable.
- Define an `IEntity` interface:
  - Add an id property of type `Guid` that is init-only setter.
  - Add a Name property that is string.
- Define an abstract base class that implements `IEntity` - appropriately choosing to implement the interface explicitly or implicitly.
- Define book, student, and employee records - all with entity capabilities.
- Provide a comment on the interface method explaining why you implemented it implicitly or explicitly.

- Unit tests for the Storage class using various entities to ensure that there are not bugs.


- There is an existing `BaseLogger` class. It needs an **auto property** to hold the class name. This property should be set in the `LogFactory` using an **object initializer**. ❌✔
- Create a `FileLogger` that derives from `BaseLogger`. It should take in a path to a file to write the log message to. When its `Log` method is called, it should **append** messages on their own line in the file. The output should include all of the following:
  - The current date/time ❌✔
  - The name of the class that created the logger ❌✔
  - The log level ❌✔
  - The message ❌✔
  - The format may vary, but an example might look like this "10/7/2019 12:38:59 AM FileLoggerTests Warning: Test message"
- The `LogFactory` should be updated with a new method `ConfigureFileLogger`. This should take in a file path and store it in a **private member**. It should use this when instantiating a new `FileLogger` in its `CreateLogger` method. ❌✔
- If the file logger has not be configured in the `LogFactory`, its `CreateLogger` method should return `null`. ❌✔
- Inside of `BaseLoggerMixins` implement **extension methods** on `BaseLogger` for
  - `Error`, ❌✔
  - `Warning`, ❌✔
  - `Information`, and ❌✔
  - `Debug`. ❌✔
  Each of these methods should take in a `string` for the message, as well as a **parameter array** of arguments for the message. Each of these extension methods is expected to be a shortcut for calling the `BaseLogger.Log` method, by automatically supplying the appropriate `LogLevel`. These methods should throw an exception if the `BaseLogger` parameter is null. There are a couple example unit tests to get you started.
- Use the nameof() operator when identifying the class name to the logger ❌✔


- Ensure that you turn on code analysis (EnableNETAnalyzers) ❌✔
- Ensure that you turn on CodeAnalysisTreatWarningsAsErrors ❌✔
- Set `LangVersion` to 11.0 ❌✔
- Turn on Nullability (`Nullable`) ❌✔
- **All of the above should be unit tested.**

- Define an `IEntity` interface.  ❌✔
  - Add an id property of type `Guid` that is init-only setter. ❌✔
  - Add a Name property that is of type string. ❌✔
- Define an abstract base class that implements `IEntity` - appropriately choosing to implement the interface explicitly or implicitly. ❌✔
  - Do not implement the `Name` property in this abstract class. ❌✔
  - Do force any derived classes to provide an implementation for `Name`. ❌✔
- Define book, student, and employee records - all with entity capabilities. ❌✔
  - Choose a thoughtful approach for the value of `Name` for each type of entity. In all cases, there should be no backing field for Name (not even one generated by an automatically implemented property) - consider a calculated property. ❌✔
  - Provide a comment on each interface **member**<!--  --> in each entity explaining why you implemented it implicitly or explicitly. ❌✔
  - Test that the equality behavior on these entities behaves as expected. ❌✔

- Implement a `GetFormatMessage()` on BaseLogger that provides the full output "line" or "value" using comma-separated values for date/time, log source, log level, and message. (The format of the output should not be defined/formatted in a deriving class.) ❌✔
- Provide a test that uses the DataRow attribute to specify a variety of string values that match LogLevel enum names. ❌✔
  - Inside the test, parse the value stored in the DataRow and verifY that IT does (or does not)  match the LogLevel names. (Hint: Use a `TryParse()` method.) ❌✔

- Check back on Friday for an updated version of the assignment (no existing items will be removed or changed significantly in the update.)

## Fundamentals

- Be sure you enable:
  - Nullability for all projects  ❌✔
  - Set `LangVersion` and the `TargetFramework` to the latest released versions available (preview versions optional) ❌✔
  - Ensure that you turn on code analysis for all projects(EnableNETAnalyzers) ❌✔
- **Ensure there are no errors or warnings (including code analysis warnings)** ❌✔
- **All of the above should be unit tested** ❌✔
- **Choose simplicity over complexity** ❌✔

## Extra Credit

Refactor your project files to put common properties and/or items into a single file.
Implement a Storage class that can save and retrieve entities into memory - while still being sure. Be sure to use interfaces appropriately.

## Relevant APIs to know about


## See [Docs](https://github.com/IntelliTect-Samples/EWU-CSCD371-2023-Winter/blob/main/Docs/README.md)
